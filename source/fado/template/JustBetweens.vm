
##$tada.groovy
###foreach( $p in $params )
##    $p.typeName
##    $p.clazz
###end
###foreach( $pred in $predicates )
##    $pred.gorp
##    $pred.leftText
##    $pred.match
###end

#### TODO add null check here
##package ${packageName};
##
##import java.sql.*;
##import javax.sql.DataSource;
##import java.math.BigDecimal;
##
##public class
##	${className}
##{
####	private PreparedStatement __ps = null;
####	public final String __preparedSQL =
#####foreach( $line in $preparedSQL.split('\n') )
###### add back each '\n', then concat each line with '+', then end with ';'
####		"${line}#if($foreach.hasNext)\n#end"#if($foreach.hasNext)+ #else; #end
#####end
####	public final String __printfSQL =
#####foreach( $line in $printfSQL.split('\n') )
###### add back each '\n' (as %n), then concat each line with '+', then end with ';'
####		"${line}#if($foreach.hasNext)%n#end"#if($foreach.hasNext)+ #else; #end
#####end
####
####	/**
####		Pass a Connection. You are responsible for closing that Connection.
####		${className} is a wrapper for a PreparedStatement, not a Connection.
####	**/
####	public ${className}( Connection connection, int resultSetType, int resultSetConcurrency )
####		throws SQLException
####	{
####		__ps = connection.prepareStatement( __preparedSQL, resultSetType, resultSetConcurrency );
####	}
####
####	public ${className}( Connection connection )
####		throws SQLException
####	{
####		this( connection, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY );
####	}
####
####	/**
####		Pass a DataSource. You are responsible for closing that DataSource.
####		${className} is a wrapper for a PreparedStatement, not a Connection.
####	**/
####	public ${className}( DataSource dataSource, int resultSetType, int resultSetConcurrency )
####		throws SQLException
####	{
####		this( dataSource.getConnection(), resultSetType, resultSetConcurrency );
####	}
####
####	public ${className}( DataSource dataSource )
####		throws SQLException
####	{
####		this( dataSource, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY );
####	}
##
##	public final ${className}ResultSet execute()
##		throws SQLException
##	{
#set( $nth = 0 )
#foreach( $pred in $predicates )
	#set( $match = $pred.match )
##	// match: $match
	#if( $Comparison.isInstance( $pred ))
		#set( $nth = $nth + 1 )
		#set( $type = $helper.toMethodType( $pred.param.type ))
		#set( $op = $pred.opText )
		#if( $match == "VAL_COL" )
			#set( $method = $helper.toMethodName( $pred.rightText ))
			__ps.set${type}( ${nth}, get${op}${method}() );
		#elseif( $match == "COL_VAL" )
			#set( $method = $helper.toMethodName( $pred.leftText ))
			__ps.set${type}( ${nth}, get${method}${op}() );
		#end
	#elseif( $Between.isInstance( $pred ))
		#if( $match == "VAL_COL_COL" )
			#set( $type = $helper.toMethodType( $pred.leftParam.type ))
			#set( $lowMethod = $helper.toMethodName( $pred.lowText ))
			#set( $highMethod = $helper.toMethodName( $pred.highText ))
			#set( $nth = $nth + 1 )
			__ps.set${type}( ${nth}, getBetween${lowMethod}And${highMethod}() );
		#elseif( $match == "COL_VAL_VAL" )
			#set( $type = $helper.toMethodType( $pred.lowParam.type ))
			#set( $method = $helper.toMethodName( $pred.leftText ))
			#set( $nth = $nth + 1 )
			__ps.set${type}( ${nth}, getBetween${method}Low() );
			#set( $nth = $nth + 1 )
			__ps.set${type}( ${nth}, getBetween${method}High() );
		#end
	#elseif( $IN.isInstance( $pred ))
##		#foreach( $abc in $pred.literals )
##			#set( $nth = $nth + 1 )
##		__ps.set${type}( ${nth}, get${method}( $foreach.count ));
##		#end
	#end
#end

	}

###foreach( $term in $predicates )
##	#set( $match = $pred.match )
##	#set( $method = $helper.toMethodName( $term.columnName ))
##	#set( $var = $helper.toVariableName( $term.columnName ))
##	#set( $type = $helper.toVariableType( $term.column.type ))
##	#set( $codeList = $helper.convertToCodeList( $term ))
##
###if( $Comparison.isInstance( $term ))
##	private ${type} _${var} = $codeList[0];
##	public void set${method}( ${type} ${var} ) { _${var} = ${var}; }
##	public ${type} get${method}() { return _${var}; }
##
###elseif( $Between.isInstance( $term ))
##	BETWEEN MATCH ${term.match}
##
##	private ${type} _${var}Left = $codeList[0];
##	public void set${method}Left( ${type} ${var} ) { _${var}Left = ${var}; }
##	public ${type} get${method}Left() { return _${var}Left; }
##
##	private ${type} _${var}Right = $codeList[1];
##	public void set${method}Right( ${type} ${var} ) { _${var}Right = ${var}; }
##	public ${type} get${method}Right() { return _${var}Right; }
##
###elseif( $IN.isInstance( $term ))
##	private ${type}[] _${var}List = new ${type}[] {
##		$helper.join( ", ", $codeList )
##	};
##
###end
###end

####	public String toString()
####	{
####		return String.format( __printfSQL
#####foreach( $term in $predicates )
####	#set( $method = $helper.toMethodName( $term.columnName ))
####	#if( $Comparison.isInstance( $term ))
####			, get${method}()
####	#elseif( $Between.isInstance( $term ))
####	        , get${method}Left()
####			, get${method}Right()
####	#elseif( $IN.isInstance( $term ))
####		#foreach( $abc in $term.literals )
####			, get${method}( $foreach.count )
####		#end
####	#end
#####end
####		));
####	}
##}