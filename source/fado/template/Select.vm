## Fado's SELECT Statement Template for Java & JDBC
##
## Copyright 2022, 2014, 2011, 2010 Jason Osgood
## 
## Template Parameters:
##
##     Comparison - reference to Comparison.class
##     Between - reference to Between.class
##     IN - reference to IN.class
##     helper - Capitalization and type casting methods.
##     date - current timestamp
##     packageName - target Java package name as String
##     className - target Java class name as String
##     sourceFile - name of original .sql file
##     originalSQL - original unparsed SQL
##     preparedSQL - prepared SQL statement (containg '?' params)
##     printfSQL - like preparedSQL, but for printf
##     conditionList - conditions from prepared SQL as List<fado.Condition>
/**
* ${className}.java   ${date}
*
* Generated using Fado's Select.vm template. Original SQL:
*
## TODO: Should this be a JavaDoc @snippet?
* <pre>
* {@code
#foreach( $line in $originalSQL.split('\n') )
* $line
#end
* }
* </pre>
*
* @see ${sourceFile}
*
**/

## TODO add null check here
package ${packageName};

import java.sql.*;
import javax.sql.DataSource;
import java.math.BigDecimal;

public class
	${className}
{
	private PreparedStatement __ps = null;
	public final String __preparedSQL =
#foreach( $line in $preparedSQL.split('\n') )
## add back each '\n', then concat each line with '+', then end with ';'
		"${line}#if($foreach.hasNext)\n#end"#if($foreach.hasNext)+ #else; #end
#end

	/**
		Pass a Connection. You are responsible for closing that Connection.
		${className} is a wrapper for a PreparedStatement, not a Connection.
	**/
	public ${className}( Connection connection, int resultSetType, int resultSetConcurrency )
		throws SQLException
	{
		__ps = connection.prepareStatement( __preparedSQL, resultSetType, resultSetConcurrency );
	}

	public ${className}( Connection connection )
		throws SQLException
	{
		this( connection, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY );
	}

	/**
		Pass a DataSource. You are responsible for closing that DataSource.
		${className} is a wrapper for a PreparedStatement, not a Connection.
	**/
	public ${className}( DataSource dataSource, int resultSetType, int resultSetConcurrency )
		throws SQLException
	{
		this( dataSource.getConnection(), resultSetType, resultSetConcurrency );
	}

	public ${className}( DataSource dataSource )
		throws SQLException
	{
		this( dataSource, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY );
	}

	public final ${className}ResultSet execute()
		throws SQLException
	{
#set( $nth = 0 )
#foreach( $condition in $conditionList )
	#set( $method = $helper.toMethodName( $condition.columnName ))
	#set( $type = $helper.toMethodType( $condition.column.type ))
	#if( $Comparison.isInstance( $condition ))
		#set( $nth = $nth + 1 )
		__ps.set${type}( ${nth}, get${method}() );
	#elseif( $Between.isInstance( $condition ))
		#set( $nth = $nth + 1 )
		__ps.set${type}( ${nth}, get${method}Left() );
		#set( $nth = $nth + 1 )
		__ps.set${type}( ${nth}, get${method}Right() );
	#elseif( $IN.isInstance( $condition ))
		#foreach( $abc in $condition.literals )
			#set( $nth = $nth + 1 )
		__ps.set${type}( ${nth}, get${method}( $foreach.count ));
		#end
	#end
#end

		ResultSet rs = null;
		if( __ps.execute() )
		{
			rs = __ps.getResultSet();
		}
		${className}ResultSet result = new ${className}ResultSet( rs );
		return result;
	}

#foreach( $condition in $conditionList )
#set( $method = $helper.toMethodName( $condition.columnName ))
#set( $var = $helper.toVariableName( $condition.columnName ))
#set( $type = $helper.toVariableType( $condition.column.type ))
#set( $codeList = $helper.convertToCodeList( $condition ))

#if( $Comparison.isInstance( $condition ))
	private ${type} _${var} = $codeList[0];
	public void set${method}( ${type} ${var} ) { _${var} = ${var}; }
	public ${type} get${method}() { return _${var}; }

#elseif( $Between.isInstance( $condition ))
	private ${type} _${var}Left = $codeList[0];
	public void set${method}Left( ${type} ${var} ) { _${var}Left = ${var}; }
	public ${type} get${method}Left() { return _${var}Left; }

	private ${type} _${var}Right = $codeList[1];
	public void set${method}Right( ${type} ${var} ) { _${var}Right = ${var}; }
	public ${type} get${method}Right() { return _${var}Right; }

#elseif( $IN.isInstance( $condition ))
	private ${type}[] _${var}List = new ${type}[] {
		$helper.join( ", ", $codeList )
	};
	private int _${var}Count = 0;
	public void add${method}Param( ${type} ${var} )
	{
		if( _${var}Count == _${var}List.length )
		{
			throw new IndexOutOfBoundsException( "IN condition parameter array only has room for: " + _${var}List.length );
		}
		int count = _${var}Count;

		// Parameter array get filled to the right, so there are no holes
		for( int i = count; count < _${var}List.length; count++ )
		{
			_${var}List[i] = ${var};
		}
		_${var}Count++;
	}

	public ${type} get${method}( int nth )
	{
		return _${var}List[ nth ];
	}
#end
#end

## TODO: printfSQL for easier debugging
##	public String toString()
##	{
##		String result = getSQL();
####
###foreach( $condition in $conditionList )
####
###if( $condition.isIN() )
####
###set( $size = $condition.getValues().size() - 1 )
###foreach( $abc in [0..$size] )
##		result = result.replaceFirst( "\\?", quotifyString( get${method}( ${abc} )));
###end
####
###elseif( $condition.isBETWEEN() )
####
##		result = result.replaceFirst( "\\?", quotifyString( get${method}Left() ));
##		result = result.replaceFirst( "\\?", quotifyString( get${method}Right() ));
###elseif( $condition.isComparison() || $condition.isLIKE() )
##		result = result.replaceFirst( "\\?", quotifyString( get${method}() ));
###end
###end
##		return result;
##	}
##
##	private String quotifyString( Object value )
##	{
##		if( value instanceof String )
##		{
##			return "'" + value.toString() + "'";
##		}
##		else
##		{
##			return value.toString();
##		}
##	}
}